using System;
using System.Numerics;
using System.Runtime.InteropServices;

namespace OpenBlasSharp
{
    public static partial class Lapack
    {
        /// <summary>
        /// <para>
        ///    ZHSEQR computes the eigenvalues of a Hessenberg matrix H
        ///    and, optionally, the matrices T and Z from the Schur decomposition
        ///    H = Z T Z**H, where T is an upper triangular matrix (the
        ///    Schur form), and Z is the unitary matrix of Schur vectors.
        /// </para>
        /// <para>
        ///    Optionally Z may be postmultiplied into an input unitary
        ///    matrix Q so that this routine can give the Schur factorization
        ///    of a matrix A which has been reduced to the Hessenberg form H
        ///    by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.
        /// </para>
        /// </summary>
        /// <param name="matrixLayout">
        /// Specifies the matrix layout.
        /// </param>
        /// <param name="job">
        /// [in] JOB is CHARACTER*1.
        /// = &#39;E&#39;:  compute eigenvalues only;
        /// = &#39;S&#39;:  compute eigenvalues and the Schur form T.
        /// </param>
        /// <param name="compz">
        /// [in] COMPZ is CHARACTER*1.
        /// = &#39;N&#39;:  no Schur vectors are computed;
        /// = &#39;I&#39;:  Z is initialized to the unit matrix and the matrix Z
        /// of Schur vectors of H is returned;
        /// = &#39;V&#39;:  Z must contain an unitary matrix Q on entry, and
        /// the product Q*Z is returned.
        /// </param>
        /// <param name="n">
        /// [in] N is INTEGER.
        /// The order of the matrix H.  N &gt;= 0.
        /// </param>
        /// <param name="ilo">
        /// [in] ILO is INTEGER.
        /// </param>
        /// <param name="ihi">
        /// [in] IHI is INTEGER.
        /// 
        /// It is assumed that H is already upper triangular in rows
        /// and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
        /// set by a previous call to ZGEBAL, and then passed to ZGEHRD
        /// when the matrix output by ZGEBAL is reduced to Hessenberg
        /// form. Otherwise ILO and IHI should be set to 1 and N
        /// respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
        /// If N = 0, then ILO = 1 and IHI = 0.
        /// </param>
        /// <param name="h">
        /// [in,out] H is COMPLEX*16 array, dimension (LDH,N).
        /// On entry, the upper Hessenberg matrix H.
        /// On exit, if INFO = 0 and JOB = &#39;S&#39;, H contains the upper
        /// triangular matrix T from the Schur decomposition (the
        /// Schur form). If INFO = 0 and JOB = &#39;E&#39;, the contents of
        /// H are unspecified on exit.  (The output value of H when
        /// INFO &gt; 0 is given under the description of INFO below.)
        /// 
        /// Unlike earlier versions of ZHSEQR, this subroutine may
        /// explicitly H(i,j) = 0 for i &gt; j and j = 1, 2, ... ILO-1
        /// or j = IHI+1, IHI+2, ... N.
        /// </param>
        /// <param name="ldh">
        /// [in] LDH is INTEGER.
        /// The leading dimension of the array H. LDH &gt;= max(1,N).
        /// </param>
        /// <param name="w">
        /// [out] W is COMPLEX*16 array, dimension (N).
        /// The computed eigenvalues. If JOB = &#39;S&#39;, the eigenvalues are
        /// stored in the same order as on the diagonal of the Schur
        /// form returned in H, with W(i) = H(i,i).
        /// </param>
        /// <param name="z">
        /// [in,out] Z is COMPLEX*16 array, dimension (LDZ,N).
        /// If COMPZ = &#39;N&#39;, Z is not referenced.
        /// If COMPZ = &#39;I&#39;, on entry Z need not be set and on exit,
        /// if INFO = 0, Z contains the unitary matrix Z of the Schur
        /// vectors of H.  If COMPZ = &#39;V&#39;, on entry Z must contain an
        /// N-by-N matrix Q, which is assumed to be equal to the unit
        /// matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
        /// if INFO = 0, Z contains Q*Z.
        /// Normally Q is the unitary matrix generated by ZUNGHR
        /// after the call to ZGEHRD which formed the Hessenberg matrix
        /// H. (The output value of Z when INFO &gt; 0 is given under
        /// the description of INFO below.)
        /// </param>
        /// <param name="ldz">
        /// [in] LDZ is INTEGER.
        /// The leading dimension of the array Z.  if COMPZ = &#39;I&#39; or
        /// COMPZ = &#39;V&#39;, then LDZ &gt;= MAX(1,N).  Otherwise, LDZ &gt;= 1.
        /// </param>
        /// <returns>
        /// = 0:  successful exit
        /// &lt; 0:  if INFO = -i, the i-th argument had an illegal
        /// value
        /// &gt; 0:  if INFO = i, ZHSEQR failed to compute all of
        /// the eigenvalues.  Elements 1:ilo-1 and i+1:n of W
        /// contain those eigenvalues which have been
        /// successfully computed.  (Failures are rare.)
        /// 
        /// If INFO &gt; 0 and JOB = &#39;E&#39;, then on exit, the
        /// remaining unconverged eigenvalues are the eigen-
        /// values of the upper Hessenberg matrix rows and
        /// columns ILO through INFO of the final, output
        /// value of H.
        /// 
        /// If INFO &gt; 0 and JOB   = &#39;S&#39;, then on exit
        /// 
        /// (*)  (initial value of H)*U  = U*(final value of H)
        /// 
        /// where U is a unitary matrix.  The final
        /// value of  H is upper Hessenberg and triangular in
        /// rows and columns INFO+1 through IHI.
        /// 
        /// If INFO &gt; 0 and COMPZ = &#39;V&#39;, then on exit
        /// 
        /// (final value of Z)  =  (initial value of Z)*U
        /// 
        /// where U is the unitary matrix in (*) (regard-
        /// less of the value of JOB.)
        /// 
        /// If INFO &gt; 0 and COMPZ = &#39;I&#39;, then on exit
        /// (final value of Z)  = U
        /// where U is the unitary matrix in (*) (regard-
        /// less of the value of JOB.)
        /// 
        /// If INFO &gt; 0 and COMPZ = &#39;N&#39;, then Z is not
        /// accessed.
        /// </returns>
        /// <remarks>
        /// <para>
        ///             Default values supplied by
        ///             ILAENV(ISPEC,&#39;ZHSEQR&#39;,JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
        ///             It is suggested that these defaults be adjusted in order
        ///             to attain best performance in each particular
        ///             computational environment.
        /// </para>
        /// <para>
        ///            ISPEC=12: The ZLAHQR vs ZLAQR0 crossover point.
        ///                      Default: 75. (Must be at least 11.)
        /// </para>
        /// <para>
        ///            ISPEC=13: Recommended deflation window size.
        ///                      This depends on ILO, IHI and NS.  NS is the
        ///                      number of simultaneous shifts returned
        ///                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
        ///                      The default for (IHI-ILO+1) &lt;= 500 is NS.
        ///                      The default for (IHI-ILO+1) &gt;  500 is 3*NS/2.
        /// </para>
        /// <para>
        ///            ISPEC=14: Nibble crossover point. (See IPARMQ for
        ///                      details.)  Default: 14% of deflation window
        ///                      size.
        /// </para>
        /// <para>
        ///            ISPEC=15: Number of simultaneous shifts in a multishift
        ///                      QR iteration.
        /// </para>
        /// <para>
        ///                      If IHI-ILO+1 is ...
        /// </para>
        /// <para>
        ///                      greater than      ...but less    ... the
        ///                      or equal to ...      than        default is
        /// </para>
        /// <para>
        ///                           1               30          NS =   2(+)
        ///                          30               60          NS =   4(+)
        ///                          60              150          NS =  10(+)
        ///                         150              590          NS =  **
        ///                         590             3000          NS =  64
        ///                        3000             6000          NS = 128
        ///                        6000             infinity      NS = 256
        /// </para>
        /// <para>
        ///                  (+)  By default some or all matrices of this order
        ///                       are passed to the implicit double shift routine
        ///                       ZLAHQR and this parameter is ignored.  See
        ///                       ISPEC=12 above and comments in IPARMQ for
        ///                       details.
        /// </para>
        /// <para>
        ///                 (**)  The asterisks (**) indicate an ad-hoc
        ///                       function of N increasing from 10 to 64.
        /// </para>
        /// <para>
        ///            ISPEC=16: Select structured matrix multiply.
        ///                      If the number of simultaneous shifts (specified
        ///                      by ISPEC=15) is less than 14, then the default
        ///                      for ISPEC=16 is 0.  Otherwise the default for
        ///                      ISPEC=16 is 2.
        /// </para>
        /// </remarks>
        [DllImport(OpenBlas.LibraryName, EntryPoint = "LAPACKE_zhseqr", CallingConvention = CallingConvention.Cdecl)]
        public static extern unsafe LapackInfo Zhseqr(
            MatrixLayout matrixLayout,
            char job,
            char compz,
            int n,
            int ilo,
            int ihi,
            Complex* h,
            int ldh,
            Complex* w,
            Complex* z,
            int ldz);
    }
}
